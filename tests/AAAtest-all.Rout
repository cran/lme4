
R Under development (unstable) (2015-06-05 r68478) -- "Unsuffered Consequences"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: i686-pc-linux-gnu (32-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> if(require("testthat", quietly = TRUE)) {
+     pkg   <- "lme4"
+     require(pkg, character.only=TRUE, quietly=TRUE)
+     test_package(pkg)
+     print(warnings()) # TODO? catch most of these by expect_warning(..)
+ } else {
+     cat( "package 'testthat' not available, cannot run unit tests\n" )
+ }
storing warnings, convergence status, etc. : ..
testing '||' notation for independent ranefs : ..........
factor handling in grouping variables : ...
data= argument and formula evaluation : .......................................
fitting glmer models : ...........................................................
glmFamily linkInv and muEta : ................................................................
glmFamily linkFun and variance : ........................................................
glmFamily devResid and aic : ........................
negative binomial : .........
Errors and warnings from glmer : ........
fitting lmer models : ............................................1....
lmerResp objects : ..........
glmResp objects : ................
summary : .
anova : ..............
bootMer confint() : .......
confint : .
refit : ...
predict : ...................
simulate : .......................
misc : ....
plot : .....
misc : .
NA handling : ...............2....3
.testing fixed-effect design matrices for full rank : .................
residuals : ........................
specifying starting values : ................
.summarizing/printing models : 
Utilities (including *non*-exported ones : .......................

1. Error: lmer -----------------------------------------------------------------
NA/NaN/Inf in 'y'
1: withCallingHandlers(eval(code, new_test_environment), error = capture_calls, message = function(c) invokeRestart("muffleMessage"), 
       warning = function(c) invokeRestart("muffleWarning"))
2: eval(code, new_test_environment)
3: eval(expr, envir, enclos)
4: expect_is(lFormula(y ~ (1 | sample) + (1 | day) + (1 | operator) + (1 | day:sample) + 
       (1 | day:operator) + (1 | sample:operator) + (1 | day:sample:operator), data = dat, 
       control = lmerControl(check.nobs.vs.rankZ = "stop")), "list") at test-lmer.R:88
5: expect_that(object, is_a(class), info, label)
6: condition(object)
7: paste0(class(x), collapse = ", ")
8: lFormula(y ~ (1 | sample) + (1 | day) + (1 | operator) + (1 | day:sample) + (1 | 
       day:operator) + (1 | sample:operator) + (1 | day:sample:operator), data = dat, 
       control = lmerControl(check.nobs.vs.rankZ = "stop"))
9: stop("NA/NaN/Inf in 'y'")
10: .handleSimpleError(function (e) 
   {
       e$calls <- head(sys.calls()[-seq_len(frame + 7)], -2)
       signalCondition(e)
   }, "NA/NaN/Inf in 'y'", quote(lFormula(y ~ (1 | sample) + (1 | day) + (1 | operator) + 
       (1 | day:sample) + (1 | day:operator) + (1 | sample:operator) + (1 | day:sample:operator), 
       data = dat, control = lmerControl(check.nobs.vs.rankZ = "stop"))))

2. Error: naming ---------------------------------------------------------------
NA/NaN/Inf in 'y'
1: withCallingHandlers(eval(code, new_test_environment), error = capture_calls, message = function(c) invokeRestart("muffleMessage"), 
       warning = function(c) invokeRestart("muffleWarning"))
2: eval(code, new_test_environment)
3: eval(expr, envir, enclos)
4: update(fm1, data = sleepstudyNA, control = lmerControl(check.conv.grad = "ignore"), 
       na.action = na.pass) at test-NAhandling.R:39
5: update.merMod(fm1, data = sleepstudyNA, control = lmerControl(check.conv.grad = "ignore"), 
       na.action = na.pass)
6: tryCatch(eval(call, envir = ff), error = function(e) {
       tryCatch(eval(call, envir = sf), error = function(e) {
           eval(call, pf)
       })
   })
7: tryCatchList(expr, classes, parentenv, handlers)
8: tryCatchOne(expr, names, parentenv, handlers[[1L]])
9: value[[3L]](cond)
10: tryCatch(eval(call, envir = sf), error = function(e) {
       eval(call, pf)
   })
11: tryCatchList(expr, classes, parentenv, handlers)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: value[[3L]](cond)
14: eval(call, pf)
15: eval(expr, envir, enclos)
16: lmer(formula = Reaction ~ Days + (Days | Subject), data = sleepstudyNA, control = lmerControl(check.conv.grad = "ignore"), 
       na.action = na.pass)
17: eval(mc, parent.frame(1L))
18: eval(expr, envir, enclos)
19: lme4::lFormula(formula = Reaction ~ Days + (Days | Subject), data = sleepstudyNA, 
       control = structure(list(optimizer = "bobyqa", restart_edge = TRUE, boundary.tol = 1e-05, 
           calc.derivs = TRUE, use.last.params = FALSE, checkControl = structure(list(
               check.nobs.vs.rankZ = "ignore", check.nobs.vs.nlev = "stop", check.nlev.gtreq.5 = "ignore", 
               check.nlev.gtr.1 = "stop", check.nobs.vs.nRE = "stop", check.rankX = "message+drop.cols", 
               check.scaleX = "warning", check.formula.LHS = "stop"), .Names = c("check.nobs.vs.rankZ", 
           "check.nobs.vs.nlev", "check.nlev.gtreq.5", "check.nlev.gtr.1", "check.nobs.vs.nRE", 
           "check.rankX", "check.scaleX", "check.formula.LHS")), checkConv = structure(list(
               check.conv.grad = structure(list(action = "ignore", tol = 0.002, relTol = NULL), .Names = c("action", 
               "tol", "relTol")), check.conv.singular = structure(list(action = "ignore", 
                   tol = 1e-04), .Names = c("action", "tol")), check.conv.hess = structure(list(
                   action = "warning", tol = 1e-06), .Names = c("action", "tol"))), .Names = c("check.conv.grad", 
           "check.conv.singular", "check.conv.hess")), optCtrl = list()), .Names = c("optimizer", 
       "restart_edge", "boundary.tol", "calc.derivs", "use.last.params", "checkControl", 
       "checkConv", "optCtrl"), class = c("lmerControl", "merControl")), na.action = na.pass)
20: stop("NA/NaN/Inf in 'y'")
21: .handleSimpleError(function (e) 
   {
       e$calls <- head(sys.calls()[-seq_len(frame + 7)], -2)
       signalCondition(e)
   }, "NA/NaN/Inf in 'y'", quote(lme4::lFormula(formula = Reaction ~ Days + (Days | 
       Subject), data = sleepstudyNA, control = structure(list(optimizer = "bobyqa", 
       restart_edge = TRUE, boundary.tol = 1e-05, calc.derivs = TRUE, use.last.params = FALSE, 
       checkControl = structure(list(check.nobs.vs.rankZ = "ignore", check.nobs.vs.nlev = "stop", 
           check.nlev.gtreq.5 = "ignore", check.nlev.gtr.1 = "stop", check.nobs.vs.nRE = "stop", 
           check.rankX = "message+drop.cols", check.scaleX = "warning", check.formula.LHS = "stop"), .Names = c("check.nobs.vs.rankZ", 
       "check.nobs.vs.nlev", "check.nlev.gtreq.5", "check.nlev.gtr.1", "check.nobs.vs.nRE", 
       "check.rankX", "check.scaleX", "check.formula.LHS")), checkConv = structure(list(
           check.conv.grad = structure(list(action = "ignore", tol = 0.002, relTol = NULL), .Names = c("action", 
           "tol", "relTol")), check.conv.singular = structure(list(action = "ignore", 
               tol = 1e-04), .Names = c("action", "tol")), check.conv.hess = structure(list(
               action = "warning", tol = 1e-06), .Names = c("action", "tol"))), .Names = c("check.conv.grad", 
       "check.conv.singular", "check.conv.hess")), optCtrl = list()), .Names = c("optimizer", 
   "restart_edge", "boundary.tol", "calc.derivs", "use.last.params", "checkControl", 
   "checkConv", "optCtrl"), class = c("lmerControl", "merControl")), na.action = na.pass)))

3. Error: other_NA -------------------------------------------------------------
NA/NaN/Inf in 'y'
1: withCallingHandlers(eval(code, new_test_environment), error = capture_calls, message = function(c) invokeRestart("muffleMessage"), 
       warning = function(c) invokeRestart("muffleWarning"))
2: eval(code, new_test_environment)
3: eval(expr, envir, enclos)
4: update(fm1, na.action = na.pass) at test-NAhandling.R:63
5: update.merMod(fm1, na.action = na.pass)
6: tryCatch(eval(call, envir = ff), error = function(e) {
       tryCatch(eval(call, envir = sf), error = function(e) {
           eval(call, pf)
       })
   })
7: tryCatchList(expr, classes, parentenv, handlers)
8: tryCatchOne(expr, names, parentenv, handlers[[1L]])
9: value[[3L]](cond)
10: tryCatch(eval(call, envir = sf), error = function(e) {
       eval(call, pf)
   })
11: tryCatchList(expr, classes, parentenv, handlers)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: value[[3L]](cond)
14: eval(call, pf)
15: eval(expr, envir, enclos)
16: lmer(formula = angle ~ recipe * temperature + (1 | recipe:replicate), data = cake2, 
       na.action = na.pass)
17: eval(mc, parent.frame(1L))
18: eval(expr, envir, enclos)
19: lme4::lFormula(formula = angle ~ recipe * temperature + (1 | recipe:replicate), data = cake2, 
       na.action = na.pass, control = structure(list(optimizer = "bobyqa", restart_edge = TRUE, 
           boundary.tol = 1e-05, calc.derivs = TRUE, use.last.params = FALSE, checkControl = structure(list(
               check.nobs.vs.rankZ = "ignore", check.nobs.vs.nlev = "stop", check.nlev.gtreq.5 = "ignore", 
               check.nlev.gtr.1 = "stop", check.nobs.vs.nRE = "stop", check.rankX = "message+drop.cols", 
               check.scaleX = "warning", check.formula.LHS = "stop"), .Names = c("check.nobs.vs.rankZ", 
           "check.nobs.vs.nlev", "check.nlev.gtreq.5", "check.nlev.gtr.1", "check.nobs.vs.nRE", 
           "check.rankX", "check.scaleX", "check.formula.LHS")), checkConv = structure(list(
               check.conv.grad = structure(list(action = "warning", tol = 0.002, relTol = NULL), .Names = c("action", 
               "tol", "relTol")), check.conv.singular = structure(list(action = "ignore", 
                   tol = 1e-04), .Names = c("action", "tol")), check.conv.hess = structure(list(
                   action = "warning", tol = 1e-06), .Names = c("action", "tol"))), .Names = c("check.conv.grad", 
           "check.conv.singular", "check.conv.hess")), optCtrl = list()), .Names = c("optimizer", 
       "restart_edge", "boundary.tol", "calc.derivs", "use.last.params", "checkControl", 
       "checkConv", "optCtrl"), class = c("lmerControl", "merControl")))
20: stop("NA/NaN/Inf in 'y'")
21: .handleSimpleError(function (e) 
   {
       e$calls <- head(sys.calls()[-seq_len(frame + 7)], -2)
       signalCondition(e)
   }, "NA/NaN/Inf in 'y'", quote(lme4::lFormula(formula = angle ~ recipe * temperature + 
       (1 | recipe:replicate), data = cake2, na.action = na.pass, control = structure(list(
       optimizer = "bobyqa", restart_edge = TRUE, boundary.tol = 1e-05, calc.derivs = TRUE, 
       use.last.params = FALSE, checkControl = structure(list(check.nobs.vs.rankZ = "ignore", 
           check.nobs.vs.nlev = "stop", check.nlev.gtreq.5 = "ignore", check.nlev.gtr.1 = "stop", 
           check.nobs.vs.nRE = "stop", check.rankX = "message+drop.cols", check.scaleX = "warning", 
           check.formula.LHS = "stop"), .Names = c("check.nobs.vs.rankZ", "check.nobs.vs.nlev", 
       "check.nlev.gtreq.5", "check.nlev.gtr.1", "check.nobs.vs.nRE", "check.rankX", 
       "check.scaleX", "check.formula.LHS")), checkConv = structure(list(check.conv.grad = structure(list(
           action = "warning", tol = 0.002, relTol = NULL), .Names = c("action", "tol", 
       "relTol")), check.conv.singular = structure(list(action = "ignore", tol = 1e-04), .Names = c("action", 
       "tol")), check.conv.hess = structure(list(action = "warning", tol = 1e-06), .Names = c("action", 
       "tol"))), .Names = c("check.conv.grad", "check.conv.singular", "check.conv.hess"
       )), optCtrl = list()), .Names = c("optimizer", "restart_edge", "boundary.tol", 
   "calc.derivs", "use.last.params", "checkControl", "checkConv", "optCtrl"), class = c("lmerControl", 
   "merControl")))))
Error: Test failures
Execution halted
